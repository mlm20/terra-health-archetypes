# Exhaustive Terra API & SDK Context for AI Assistants (Based on Provided Docs)

**Document Version:** Based on the PDF export "Terra Docs" (173 pages).

**Goal:** Provide comprehensive, detailed context on the entire Terra ecosystem (APIs, SDKs, Concepts, Setup, Debugging) for an AI assistant to effectively help developers implement Terra.

## 1. Introduction & Core Concepts

**1.1. What is Terra?**
Terra offers a suite of APIs and SDKs designed to unify access to health, fitness, and sensor data from a vast array of sources. It acts as a single integration point, abstracting the complexities of individual provider APIs (like Garmin, Fitbit, Apple Health, Strava, Freestyle Libre, etc.).

**1.2. Problems Solved:**
*   Eliminates the need for developers to build and maintain separate integrations for each data provider.
*   Provides standardized data formats across different sources.
*   Offers real-time data streaming capabilities.
*   Manages authentication flows with various providers.

**1.3. Main Terra Components:**

*   **Health & Fitness API (Web API):** Primarily for server-to-server interactions. Used for fetching historical data, receiving data updates via webhooks, and writing data (like planned workouts) back to certain providers.
*   **Mobile SDKs:** Native libraries for iOS (Swift), Android (Kotlin), and wrappers for React Native and Flutter. **Required** for accessing data sources that *lack* a web API (Apple Health, Samsung Health, Google Fit via Health Connect). Also used as the "Producer" component in the Streaming API.
*   **Streaming API:** Enables real-time data transmission (e.g., heart rate per second) using WebSockets. Involves:
    *   **Producer:** Usually a mobile app using a Terra Real-Time (RT) SDK, connected to a wearable (BLE/ANT+).
    *   **Broker:** Terra's central WebSocket server.
    *   **Consumer:** Your backend service listening to the WebSocket stream from the broker.
*   **Teams API [BETA]:** Connects to specialized sports science equipment (dynamometers, player tracking units).
*   **Biomarkers API [Upcoming]:** (Mentioned as upcoming, no details in docs).
*   **Terra Dashboard:** The web portal for managing your Terra account, API keys, enabling/disabling provider integrations (Data Sources), configuring data destinations (Webhooks), testing endpoints (Payload Simulator), and debugging user connections.

**1.4. Key Terminology:**

*   **Provider:** The origin of the health/fitness data (e.g., Garmin, Fitbit, Apple Health, Strava).
*   **Integration:** Connecting Terra to a specific Provider. Enabled/disabled in the Dashboard.
*   **Data Source:** A specific Provider integration that you enable.
*   **Destination:** The URL (typically your backend webhook endpoint) where Terra sends data updates and events. Configured in the Dashboard.
*   **User:** An end-user whose data you are accessing via Terra. Represented by a unique `user_id` generated by Terra upon successful authentication with a provider.
*   **Developer ID (`dev_id`):** Your unique Terra account identifier. Required in API calls/SDK initialization.
*   **API Key (`x-api-key`):** Your secret key for authenticating server-side API calls. **CRITICAL: Never expose this on the client-side (mobile app/frontend).**
*   **Scope:** Permissions requested from the end-user during the authentication flow (e.g., read activity, read sleep, write workouts). Customizable in the Terra Dashboard per provider.
*   **`reference_id`:** An *optional* identifier you can pass during the user authentication setup. Terra associates this with the generated `user_id`. Use this to map the Terra `user_id` back to *your* internal user ID system. Crucial for linking data correctly.
*   **Event:** A JSON payload sent by Terra to your Destination webhook. Types include `auth` (authentication results) and data types (`activity`, `daily`, `sleep`, etc.).
*   **Widget:** Terra's pre-built UI component (hosted URL) for handling user authentication and provider selection.
*   **SDK (Software Development Kit):** Libraries for mobile platforms (iOS, Android, RN, Flutter) to interact with Terra, especially for mobile-only data sources and real-time streaming production. Includes standard SDKs and Real-Time (RT) SDKs.
*   **Webhook:** An HTTP callback mechanism. Terra sends POST requests with event data to your registered Destination URL.
*   **Token:**
    *   **API Key:** Used for server-to-server authentication.
    *   **Auth Token (SDK Init):** Single-use token generated by your backend (`POST /v2/auth/generateAuthToken`) and passed to the mobile SDK's `initConnection` function for connecting mobile-only sources.
    *   **Streaming Token (Producer):** Generated by your backend (`POST /auth/user` with `user_id`) and passed to the mobile RT SDK's `startRealtime` function to allow the app to send data *to* the Terra broker.
    *   **Consumer Token (Streaming Auth):** Your Terra API Key (`x-api-key`) used in the `IDENTIFY` payload when your backend connects to the WebSocket broker as a consumer.

---

## 2. Health & Fitness API (Web API)

**Purpose:** Server-side interaction for historical data, webhooks, and writing planned workouts.

**2.1. Overview / Workflow Steps:**

1.  **Set up Integrations & Destinations:** Configure data sources and webhook endpoint in the Terra Dashboard.
2.  **Connect a User (Authentication):** Guide the user through authenticating their provider account with Terra to get a `user_id`.
3.  **Receive Data Updates:** Listen for incoming webhooks with new data at your Destination URL.
4.  **Request Historical Data:** Optionally fetch past data using REST API GET requests.
5.  **Write Data:** Send planned workouts to supported providers using REST API POST requests.

**2.2. Setup: Integrations & Destinations (Terra Dashboard)**

*   Navigate to the "Connections" page in your Terra Dashboard.
*   **Data Sources:** Enable the specific providers (e.g., Fitbit, Garmin, Strava) you want to support.
*   **Destinations:** Configure at least one Destination. This is typically your backend server's endpoint URL that will receive POST requests (webhooks) from Terra.
    *   For initial testing and development, use a service like `https://webhook.site` to easily inspect incoming payloads without setting up your own server endpoint immediately.
    *   Refer to the "Destinations" documentation (linked in the PDF) for details on configuring different destination types if needed.

**2.3. Connect a User (Authentication Flow)**

*   **Goal:** Securely link an end-user's account for a specific provider (e.g., their Fitbit account) to your Terra developer account and obtain a unique Terra `user_id` for that connection.
*   **Prerequisites:**
    1.  Obtain your API Key (`x-api-key`) and Developer ID (`dev_id`) from the Terra Dashboard.
    2.  Configure a Destination webhook URL.
    3.  Enable the desired Data Sources (providers) in the Dashboard.
    4.  Review the expected authentication events (see Webhooks section below).
*   **Methods for Authentication:**

    *   **Method 1: Terra Widget (Recommended)**
        *   **Backend Step:** Your server calls `POST /v2/auth/generateWidgetSession`.
            *   **Headers:** `dev-id`, `x-api-key`.
            *   **Body (JSON):**
                *   `reference_id` (string, **required**): Your internal unique ID for the user.
                *   `providers` (string, optional): Comma-separated list of providers to display (e.g., "GARMIN,FITBIT"). Defaults to all enabled providers if omitted.
                *   `language` (string, optional): Language for the widget (e.g., "en", "fr"). Defaults to browser language or "en".
                *   `auth_success_redirect_url` (string, **required**): URL user is redirected to on successful authentication.
                *   `auth_failure_redirect_url` (string, **required**): URL user is redirected to on failure/cancellation.
            *   **Response (Success 200):**
                ```json
                {
                  "status": "success",
                  "url": "https://widget.tryterra.co/session/...",
                  "session_id": "unique-session-identifier"
                }
                ```
        *   **Client-Side Step:** Open the `url` received from the backend. **Use an in-app browser (like SFSafariViewController or Chrome Custom Tabs) or a new browser tab.** **NEVER use a WebView or iframe.**
        *   **Widget Flow:** The user selects a provider, logs into their provider account, and grants permissions (scopes configured in Terra Dashboard).
        *   **Redirection:** User is redirected to your `auth_success_redirect_url` or `auth_failure_redirect_url`. Terra appends query parameters: `user_id`, `reference_id`, `resource` (provider name), `widget_session_id`. Example success redirect: `https://yourapp.com/success?user_id=...&reference_id=...&resource=GARMIN&widget_session_id=...`
        *   **Webhook Event:** An `auth` event is sent to your Destination (see section 2.4).

    *   **Method 2: Custom UI**
        *   **Backend Step 1 (Optional):** Fetch metadata for enabled integrations using `GET /integrations/detailed` (Headers: `dev-id`, `x-api-key`) to dynamically display connection buttons with logos, names, etc. Filter response using `enabled=true`.
        *   **Client-Side Step 1:** User clicks a button for a specific provider (e.g., "Connect to Fitbit").
        *   **Backend Step 2:** Your server calls `POST /user`.
            *   **Headers:** `dev-id`, `x-api-key`.
            *   **Body (JSON):**
                *   `reference_id` (string, **required**): Your internal unique ID for the user.
                *   `provider` (string, **required**): The provider the user selected (e.g., "FITBIT").
                *   `auth_success_redirect_url` (string, **required**): Success redirect URL.
                *   `auth_failure_redirect_url` (string, **required**): Failure redirect URL.
            *   **Response (Success 200):**
                ```json
                {
                  "status": "success",
                  "user_id": "terra-generated-user-id",
                  "auth_url": "https://www.fitbit.com/oauth2/authorize?..."
                }
                ```
        *   **Client-Side Step 2:** Open the `auth_url` received from the backend. **Use an in-app browser or new browser tab.** **NEVER use a WebView or iframe.**
        *   **Provider Flow:** User logs into the provider site and grants permissions.
        *   **Redirection:** User is redirected to your `auth_success_redirect_url` or `auth_failure_redirect_url`. Terra appends query parameters: `user_id`, `reference_id`, `resource`. Example success redirect: `https://yourapp.com/success?user_id=...&reference_id=...&resource=FITBIT`
        *   **Webhook Event:** An `auth` event is sent to your Destination (see section 2.4).

    *   **Method 3: Dashboard UI (Testing Only)**
        *   You can manually connect a user through the Terra Dashboard UI for testing/demo purposes without making API calls.

*   **Security Warning:** Using WebViews/iframes poses security risks (invisible URL bar, potential phishing) and may be blocked by providers. **Always use an in-app browser or new tab.**
*   **User Limits (Testing):** Testing/development environments typically have a limit of 50 users. Use the `DELETE /user` endpoint (with `user_id` or `reference_id`) or the `#auth-deauthenticateuser` endpoint reference in the docs to deregister test accounts.
*   **SDK-Based Integrations:** Apple Health, Samsung Health, Google Fit cannot be connected via these Web API flows. They require the Mobile SDKs (see Section 3).

**2.4. Receive Data Updates (Webhooks)**

*   **Mechanism:** Terra sends HTTP POST requests to your configured Destination URL when new data is available for a connected user or when authentication events occur.
*   **Prerequisites:** Active Destination URL configured, Data Sources enabled.
*   **Payload Structure (General):**
    ```json
    {
      "type": "event_type", // e.g., "auth", "activity", "daily"
      "user": {
        "user_id": "terra-user-id",
        "provider": "PROVIDER_NAME", // e.g., "GARMIN"
        "reference_id": "your-internal-user-id",
        "scopes": "Granted permissions string",
        "last_webhook_update": "timestamp or null"
        // ... other user metadata
      },
      "status": "status_string", // e.g., "success", "error" (mostly for auth)
      "data": [ /* Array of data objects for data events */ ],
      // ... other event-specific fields (message, reason, etc.)
    }
    ```
*   **Event Types:**
    *   **`auth`:** Sent after an authentication attempt.
        *   `status: "success"`: User successfully connected. Store the `user_id` and map it to your `reference_id`.
            ```json
            {
              "type": "auth",
              "status": "success",
              "widget_session_id": "...", // If using widget
              "user": { /* user details including user_id, reference_id */ },
              "reference_id": "your-internal-user-id",
              "message": "User has successfully authenticated",
              "version": "..."
            }
            ```
        *   `status: "error"`: User failed to authenticate or cancelled. Includes a `reason` field (e.g., `"auth_cancelled"`). The temporary user record is usually deleted.
            ```json
            {
              "type": "auth",
              "status": "error",
              "message": "User failed to authenticate and has been deleted",
              "reference_id": "test-username",
              "widget_session_id": "...", // If using widget
              "user": { /* user details, possibly incomplete */ },
              "reason": "auth_cancelled",
              "version": "..."
            }
            ```
    *   **`user_reauth`:** Sent when a user connects the *same provider account* again using the *same `reference_id`*. This deletes the `old_user` record and issues a `new_user` record. You **must** update your mapping from `reference_id` to the `new_user.user_id`.
        ```json
        {
          "type": "user_reauth",
          "new_user": { /* details of the new user record */ },
          "old_user": { /* details of the deleted user record */ },
          "status": "warning",
          "message": "User has reauthenticated and old ID has been deleted"
        }
        ```
        *   **Important:** This implies a one-to-many mapping possibility between your `End Users` and Terra `Users`, as the same wearable account might be connected by different end users (with different `reference_id`s).
    *   **Data Events (`activity`, `daily`, `body`, `sleep`, `menstruation`, `athlete`, `planned_workout`):** Sent when new data is synced from the provider cloud.
        *   `data`: An array containing one or more data objects of the specified type.
        *   Payload Example (`activity`):
            ```json
            {
              "type": "activity",
              "data": [
                {
                  "metadata": {
                    "type": 45, // Provider specific activity type
                    "start_time": "2024-10-03T18:17:45.000000+08:00",
                    "end_time": "2024-10-03T18:38:39.000000+08:00",
                    "summary_id": "unique-activity-identifier",
                    "name": "MEDITATION"
                    // ... other metadata
                  },
                  // ... other data fields (distance_data, heart_rate_data, etc.)
                  "... ommitted for brevity ..."
                }
              ],
              "user": { /* user details */ },
              "version": "2022-03-16"
            }
            ```
*   **Data Handling Strategy: Overwriting/Supersets:**
    *   Terra data payloads are generally **supersets** of previous data for the same logical entity.
    *   **Always overwrite** data stored on your end with the most up-to-date version received via webhook, using the appropriate unique identifier.
    *   **Unique Identifiers for Overwriting (per User):**
        *   Activity: `metadata.summary_id`
        *   Daily: `metadata.start_time` (Use **date part only**, ignore time)
        *   Body: `metadata.start_time` (Use **date part only**, ignore time)
        *   Sleep: `metadata.summary_id`
        *   Menstruation: `metadata.start_time` (Use **date part only**, ignore time)
        *   Planned Workout: `metadata.summary_id` (If applicable, check specific docs)
*   **Testing Webhooks:** Use the Payload Simulator in the Terra Dashboard to send test events to your Destination URL.
*   **Error Handling:** If your destination returns an error (e.g., 5xx HTTP status), Terra will retry sending the webhook with exponential backoff for a little over 24 hours. Ensure your endpoint is robust and returns 2xx on successful receipt.

**2.5. Request Historical Data (REST API)**

*   **Purpose:** Fetch data points from a time range *before* the user connected via Terra, or for debugging, or implementing pull-to-refresh.
*   **Prerequisites:** Valid `user_id` obtained from successful authentication. Required Data Sources and permissions enabled.
*   **Endpoints:** Use HTTP GET requests. Common endpoints:
    *   `/activity`
    *   `/daily`
    *   `/sleep`
    *   `/body`
    *   `/athlete` (Fetches user profile info, including `provider_user_id`)
    *   `/menstruation` (If applicable)
    *   `/v2/plannedWorkout` (To retrieve workouts written previously)
*   **Common Parameters:**
    *   `user_id` (query parameter, **required**): The Terra user ID.
    *   `start_date` (query parameter, **required**, format `YYYY-MM-DD`): Start of the date range.
    *   `end_date` (query parameter, optional, format `YYYY-MM-DD`): End of the date range. Defaults to current date if omitted.
    *   `to_webhook` (query parameter, boolean, optional): Controls sync/async behavior.
        *   `false` (Default for ranges <= 28 days): **Synchronous**. The API call waits (up to ~30s) and returns the data directly in the HTTP response body. Suitable for small, time-sensitive requests.
        *   `true` (Default for ranges > 28 days): **Asynchronous**. The API call returns immediately with a success message and a `terra-reference` header. Terra fetches the data in the background and sends it to your Destination webhook later in chunks. **Required for long time ranges.**
    *   `with_samples` (query parameter, boolean, optional): Include sample-level data (e.g., second-by-second HR) where available. Defaults to `false`. Can significantly increase payload size.
*   **Asynchronous Flow (`to_webhook=true`):**
    1.  Make GET request with `to_webhook=true`.
    2.  Store the `terra-reference` value returned in the response headers.
    3.  Receive an immediate `#large-request-processing` event via webhook (optional handling).
    4.  Later, receive a `#large-request-sending` event indicating the number of expected data payloads.
    5.  Receive multiple webhook POST requests containing the data chunks. Each chunk will have a `terra-signature` header matching the original `terra-reference`. Use this match to confirm the data belongs to your request.
    6.  Once all expected payloads (based on `#large-request-sending`) with the matching `terra-signature` are received, the transfer is complete.
*   **Provider Limits on Historical Data:**
    *   Garmin: 5 years back from the current time.
    *   Polar: No historical data retrieval permitted.
    *   Health Connect: 30 days back from the moment the user granted permission.
*   **Dashboard Request:** You can also trigger historical data pulls manually from the Terra Dashboard (Users tab -> Request Data) for debugging.
*   **Practical Example (Python FastAPI using `requests` - Async):**
    ```python
    import requests
    import os
    from fastapi import FastAPI, Request, HTTPException
    from datetime import datetime, timedelta

    app = FastAPI()
    TERRA_API_URL = "https://api.tryterra.co/v2" # Or the specific versioned URL from docs
    TERRA_API_KEY = os.getenv("TERRA_API_KEY")
    TERRA_DEV_ID = os.getenv("TERRA_DEVELOPER_ID")

    @app.post("/webhook")
    async def webhook_handler(request: Request):
        payload = await request.json()

        if payload.get("type") == "auth" and payload.get("status") == "success":
            user_id = payload.get("user", {}).get("user_id")
            if not user_id:
                 # Handle error: user_id missing
                 print("Auth success but user_id missing")
                 return {"message": "Auth success but user_id missing"}

            # Request data for the last 28 days asynchronously
            start_date_dt = (datetime.utcnow() - timedelta(days=28))
            end_date_dt = (datetime.utcnow() + timedelta(days=1)) # Include today fully
            start_date_str = start_date_dt.strftime('%Y-%m-%d')
            end_date_str = end_date_dt.strftime('%Y-%m-%d')

            headers = {
                "x-api-key": TERRA_API_KEY,
                "dev-id": TERRA_DEV_ID
            }
            endpoints_to_fetch = ["/activity", "/daily", "/sleep", "/body"]
            request_results = {}

            for endpoint in endpoints_to_fetch:
                try:
                    response = requests.get(
                        f"{TERRA_API_URL}{endpoint}",
                        headers=headers,
                        params={
                            "user_id": user_id,
                            "start_date": start_date_str,
                            "end_date": end_date_str,
                            "to_webhook": "true" # Asynchronous
                        }
                    )
                    response.raise_for_status() # Raises an exception for 4XX/5XX
                    # Store terra-reference if needed for tracking data chunks
                    terra_ref = response.headers.get("terra-reference")
                    request_results[endpoint] = {"status": response.status_code, "terra_reference": terra_ref}
                    print(f"Requested {endpoint} for user {user_id}, terra_reference: {terra_ref}")

                except requests.exceptions.HTTPError as e:
                    print(f"Error requesting {endpoint} for user {user_id}: {e.response.status_code} - {e.response.text}")
                    request_results[endpoint] = {"status": e.response.status_code, "error": e.response.text}
                    # Optionally raise HTTPException or handle specific errors like 401/403 immediately

            return {"message": "Historical data request(s) initiated", "details": request_results}

        elif payload.get("type") in ["activity", "daily", "sleep", "body"]:
            # Process incoming data from webhooks (historical or real-time updates)
            terra_signature = request.headers.get("terra-signature")
            print(f"Received data webhook: type={payload.get('type')}, user_id={payload.get('user',{}).get('user_id')}, terra_signature={terra_signature}")
            # Add processing logic here - store data, match terra_signature if it's from an async request
            return {"message": "Data webhook received"}

        elif payload.get("type") == "large-request-processing" or payload.get("type") == "large-request-sending":
             print(f"Received large request event: {payload.get('type')}, message: {payload.get('message')}")
             return {"message": "Large request event received"}
        
        elif payload.get("type") == "deauth":
            print(f"Received deauth event for user_id: {payload.get('user', {}).get('user_id')}")
            # Handle user deauthorization in your system
            return {"message": "Deauth event received"}

        else:
             # Handle other webhook types or ignore
            print(f"Received unhandled webhook type: {payload.get('type')}")
            return {"message": "Webhook received, not processed by this specific logic"}

        # Fallback/default response
        return {"message": "Webhook processed"}

    # Remember to implement proper security (webhook signature verification if provided by Terra),
    # error handling, and robust data storage.
    ```

**2.6. Write Data (Planned Workouts)**

*   **Purpose:** Create structured workout plans that users can follow on their wearable devices (where supported by the provider).
*   **Supported Providers:** Garmin, Hammerhead, Coros, TodaysPlan (check docs/GitHub for current list).
*   **Endpoint:** `POST /v2/plannedWorkout`
*   **Headers:**
    *   `dev-id` (string, **required**): Your Developer ID.
    *   `x-api-key` (string, **required**): Your API Key.
    *   `Content-Type`: `application/json`
*   **Body:** A JSON object containing a `data` array. Each element in the `data` array is a `PlannedWorkout` object.
    *   **`PlannedWorkout` Object:**
        *   `user_id` (string, **required**): The Terra user ID to send the workout to.
        *   `metadata` (object, **required**): Workout metadata.
            *   `name` (string, **required**): Workout name.
            *   `description` (string, optional): Workout description.
            *   `type` (enum string, **required**): Activity type (e.g., "RUNNING", "CYCLING", "LAP_SWIMMING"). From provider-specific list.
            *   `estimated_duration_seconds` (number, optional): Estimated total duration.
            *   `estimated_distance_meters` (number, optional): Estimated total distance.
            *   `planned_date` (string `YYYY-MM-DDTHH:mm:ssZ` or `YYYY-MM-DDTHH:mm:ss+00:00`, optional): Date for the workout.
            *   `estimated_calories` (number, optional)
            *   `estimated_tss` (number, optional - Training Stress Score)
            *   `estimated_tscore` (number, optional - Training Impulse Score)
            *   `estimated_if` (number, optional - Intensity Factor)
            *   `pool_length_meters` (number, optional): For swimming.
        *   `steps` (array, **required**): Array of workout steps (can be nested for repeat blocks).
            *   **Workout Step Object:**
                *   `type` (integer enum, **required**): `0` for a single step/segment, `1` for a repeat block.
                *   `order` (integer, **required**): Order of this step within its parent (0-indexed).
                *   `description` (string, optional): Name/description of the step (e.g., "Warm Up", "Interval 1").
                *   **If `type: 0` (Single Step/Segment):**
                    *   `intensity` (integer enum, optional): Intensity label (e.g., `1`: Warmup, `2`: Active, `3`: Recovery, `4`: Cooldown, `5` Active, etc. - check Terra docs for full enum).
                    *   `durations` (array, **required**): Array of `Duration` objects defining how this step ends (at least one required). Multiple durations usually mean "whichever comes first".
                    *   `targets` (array, optional): Array of `Target` objects defining target zones/values for this step.
                *   **If `type: 1` (Repeat Block):**
                    *   `durations` (array, **required**): Must contain exactly one `Duration` object with `duration_type: 9` (Repetitions) and the corresponding `reps` value.
                    *   `steps` (array, **required**): Nested array of workout step objects (type 0 or type 1) to be repeated.
            *   **`Duration` Object (defines completion criteria for a step):**
                *   `duration_type` (integer enum, **required**): e.g., `0` (Time), `1` (Distance), `2` (Calories Burned), `3` (Heart Rate Greater Than), `4` (Heart Rate Less Than), `5` (Power Greater Than), `6` (Power Less Than), `8` (Lap Button Press), `9` (Repetitions - only for repeat blocks).
                *   Value fields (number, required based on `duration_type`):
                    *   `duration_type: 0` -> `seconds`
                    *   `duration_type: 1` -> `meters`
                    *   `duration_type: 2` -> `calories`
                    *   `duration_type: 3 or 4` -> `bpm`
                    *   `duration_type: 5 or 6` -> `watts`
                    *   `duration_type: 9` -> `reps`
            *   **`Target` Object (defines target zone for a step):**
                *   `target_type` (integer enum, **required**): e.g., `0` (Pace), `1` (Speed), `2` (Cadence), `3` (Power Zone - usually 1-7), `4` (Heart Rate Zone - usually 1-5), `12` (Heart Rate % Max HR), `13` (Heart Rate % FTP/Threshold), `15` (Power % FTP). Check specific enum values in Terra docs.
                *   Value fields (number, required based on `target_type`): Define the range or single value.
                    *   For ranges: `pace_low` / `pace_high` (seconds/km or seconds/mile), `speed_low` / `speed_high` (m/s), `cadence_low` / `cadence_high` (rpm), `power_low` / `power_high` (watts), `hr_low` / `hr_high` (bpm).
                    *   For % types: `hr_percentage_low` / `hr_percentage_high`, `power_percentage_low` / `power_percentage_high`.
                    *   Use `null` for one side of an open-ended target (e.g., `hr_percentage_low: 80, hr_percentage_high: null` means "above 80%").
*   **Response (Success 201 Created):**
    ```json
    {
      "message": "text", // e.g., "Workout uploaded successfully"
      "log_ids": [ "provider_specific_workout_id1", "provider_specific_workout_id2" ], // List of IDs for the created workouts on the provider's system
      "status": "success",
      "user": { /* user details */ }
    }
    ```
    *   Store the `log_ids` if you need to retrieve or delete these specific workouts later using `GET` or `DELETE` on `/v2/plannedWorkout`. The delete endpoint uses these log IDs.
*   **Response (Error 4xx/5xx):** Standard error responses (e.g., 400 for malformed request, 404 if `user_id` not found).
*   **Example Use Case:** Creating interval training (e.g., 5x [3 min at Zone 4 Power, 2 min at Zone 1 Power]), structured warmups/cooldowns.
*   **iOS 17+:** Planned workouts can also be written *via the iOS SDK* (`postPlannedWorkout`) for Apple Health/Watch users. See Mobile SDK section.

**2.7. Provider-Specific Guides & Credentials**

*   **Integrations Subject to Change:** Provider APIs can change without notice, potentially disrupting Terra's service beyond their control.
*   **Creating Own Access Keys:** Some providers might require you to use your own application keys (obtained from their developer portal) instead of Terra's managed keys, often to avoid rate limits or comply with terms. This usually involves creating an app on the provider's platform and entering the client ID/secret into the Terra Dashboard connection settings. Providers mentioned requiring this:
    *   **Strava:**
        1.  Log in to `https://strava.com/settings/api`.
        2.  Create an application.
        3.  Set Authorization Callback Domain to `api.tryterra.co`.
        4.  Save the Client ID and Client Secret.
        5.  In Terra Dashboard (API -> Connections -> Add More -> Strava), enter the obtained Client ID and Secret in the connection settings.
    *   **Virtuagym:**
        1.  Request an API key from `https://virtuagym.com/public-api`.
        2.  In Terra Dashboard (API -> Connections -> Add More -> Virtuagym), go to options.
        3.  Fill in your portal name as the `client_id` and your API Key as the `client_secret`.
    *   **Huawei:**
        1.  Create Huawei ID & verify identity (DUNS/Business License or personal docs guides linked).
        2.  Apply for HUAWEI ID Service via AppGallery Connect (guide linked). This is where you get `client_id` and `client_secret`.
        3.  Enter obtained `client_id` and `client_secret` into Terra Dashboard for Huawei connection.
        4.  Set Redirect URL in Huawei Console (AppGallery Connect): `https://api.tryterra.co/v2/auth/huawei/oauth2`.
        5.  Set App access URL in Huawei Console: `https://api.tryterra.co/`.
        6.  Set Callback address for Health Kit webhooks (for data updates from Huawei Health Kit to Terra) in Huawei Console: `https://api.tryterra.co/v2/hooks/huawei/healthkit/notifications`. Follow webhook registration steps provided by Huawei (guide linked in Terra docs).
*   **Dedicated Credentials & Special Setup:** Some integrations (marked N/A or requiring specific credentials in the docs table, e.g., WHOOP, Dexcom, FreestyleLibre Germany/Austria/France) need credentials/setup handled via Terra support or specific configurations.
    *   **FreestyleLibre (DE, AT, FR):** Requires proof of a doctor's license / registered practice ID in those regions due to regulations. Provide details to Terra.

**2.8. Debugging FAQ (Web API Focused)**
(See also Section 7 for combined Debugging)

*   **User logged in with wrong account:** Verify `provider_user_id` from `/athlete` endpoint against provider's app/website.
*   **Data shown on provider app but not via Terra API:** Check provider's *web dashboard* first. Force sync. Check for known delays (Garmin API, Google Fit API). Check MyFitnessPal diary sharing settings.
*   **Destination Erroring (Retries):** Check your server logs for errors. Terra retries for ~24h on 5xx errors.

---

## 3. Mobile SDKs

**Purpose:**
1.  Access data from sources without a Web API (**Apple Health**, **Samsung Health**, **Google Fit via Health Connect**).
2.  Act as the **Producer** for the **Streaming API** (connect to BLE/ANT+ devices and send data to Terra broker - See Section 4 for RT SDKs). This section focuses on SDKs for accessing stored health data.

**3.1. Overview**

*   SDKs exist for iOS (Swift - `TerraiOS`), Android (Kotlin - `terra-android`), React Native (`terra-react`), and Flutter (`terra_flutter_bridge`).
*   They handle native platform interactions (HealthKit, Health Connect).
*   Require backend interaction to generate secure authentication tokens for initialization.
*   Provide functions for initializing connections, fetching data, and sometimes writing data.
*   Data flow typically involves the SDK retrieving data from the phone's health store and either returning it to the app or pushing it to your backend webhook (if `schedulerOn` or background delivery is configured and supported).

**3.2. Relevant SDK-Only Integrations:**

*   **Apple Health (iOS):** Accessed via HealthKit. SDK is the *only* way.
*   **Samsung Health (Android):** Relies on **Health Connect**. Terra SDK handles Health Connect interaction.
*   **Google Fit (Android):** Accessed via **Health Connect**. The Google Fit REST API is sunsetting (June 30, 2025). Terra SDK manages Health Connect.

**3.3. General SDK Workflow (Health Data Access):**

1.  **Install & Configure:** Add SDK dependency, configure native projects (Info.plist, AndroidManifest, capabilities, permissions, Gradle).
2.  **Initialize SDK Library:** Initialize the Terra library itself when the app starts (provide `dev_id`, optional `reference_id`). This is different from `initConnection`.
3.  **Generate Auth Token (Backend):** Your backend calls `POST /v2/auth/generateAuthToken` (using API Key) to get a single-use `token`.
4.  **Send Token to Client:** Securely transmit the token to the mobile app.
5.  **Initialize Connection (Client):** App calls SDK's `initConnection` function, passing the `token`, connection type (e.g., `.APPLE_HEALTH`, `.SAMSUNG` (for Health Connect), `.GOOGLE_FIT` (for Health Connect)), and optionally custom permissions / background delivery settings. This triggers the native permission prompt.
6.  **Fetch/Receive Data (Client):** Use SDK functions (`getDaily`, `getActivity`, etc.) to request data. Data can be returned directly to the app (if `toWebhook=false` in function call) or sent to your backend webhook (if `schedulerOn` or background delivery is configured and the function's `toWebhook` parameter is true or defaults to it).
7.  **Write Data (Client - Limited):** Some SDKs allow writing data (e.g., `postActivity`, `postNutrition` on iOS for Apple Health).

**3.4. iOS SDK (Swift) - `TerraiOS` - Health Data Access (Pages 84-97 in PDF)**

*   **Security:** API Key on backend. SDK is *only* for mobile-only integrations if not using streaming.
*   **Installation:** Swift Package Manager: `https://github.com/tryterra/TerraiOS`.
*   **Project Setup:**
    *   **Capabilities:**
        *   HealthKit: Add "HealthKit".
        *   Background Delivery: Add "Background Delivery" under HealthKit.
        *   Background Modes: Add "Background processing" and "Background fetch".
    *   **`Info.plist`:**
        *   `Privacy - Health Share Usage Description` (NSHealthShareUsageDescription): Custom text for Apple Health permission screen (read access).
        *   `Privacy - Health Update Usage Description` (NSHealthUpdateUsageDescription): Custom text if writing data.
        *   `Permitted background task scheduler identifiers` (Array): Add `co.tryterra.data.post.request`.
*   **Initialization (SDK Library):**
    ```swift
    import TerraiOS

    var terra: TerraManager? // Store as a class property

    // In AppDelegate or main app struct/class
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        Terra.instance(devId: "YOUR_DEV_ID", referenceId: "YOUR_INTERNAL_USER_ID_OR_NIL") { [weak self] managerInstance in
            self?.terra = managerInstance
            // SDK is ready, now you can call initConnection when needed
        }
        // ... other setup ...
        Terra.setUpBackgroundDelivery() // For webhook updates from HealthKit
        return true
    }
    ```
    *   Initialize `Terra.instance` once, e.g., in `didFinishLaunchingWithOptions`. It should be initialized every time the app is brought to the foreground according to docs.
*   **Initialize Connection (to Apple Health):**
    1.  **Backend:** Call `POST /v2/auth/generateAuthToken` to get `sdk_token`.
    2.  **Client (Swift):**
        ```swift
        let sdkTokenFromBackend = "..."
        let customPermissions: Set<CustomPermissions> = [] // Empty for all default, or specify e.g., [.WORKOUTS, .ACTIVITY_SUMMARY]
        let schedulerOn = true // Enable background delivery to webhook

        terra?.initConnection(
            type: .APPLE_HEALTH,
            token: sdkTokenFromBackend,
            customReadTypes: customPermissions, // For read permissions
            // customWriteTypes: customPermissions, // If writing data
            schedulerOn: schedulerOn
        ) { success, error in
            if success {
                print("Apple Health Connection successful!")
            } else if let error = error {
                print("Apple Health Connection failed: \(error.localizedDescription) - \(error.message)")
            }
        }
        ```
        *   `initConnection` only needs to be run once successfully per set of permissions. Apple Health prohibits repeated permission popups.
        *   If your app is webview-based, interrupt webview, call `initConnection`, then re-open webview.
*   **Background Delivery (Webhook Updates):** Enabled by `schedulerOn: true` and `Terra.setUpBackgroundDelivery()`. Data is sent to your Destination webhook when device is unlocked and new data is available.
*   **Validate Connection:**
    ```swift
    if let currentUserId = terra?.getUserid() { // Synchronous call
        print("Apple Health user ID: \(currentUserId)")
    } else {
        print("No active Apple Health connection or user ID.")
        // May need to call initConnection again if connection was expected
    }
    ```
*   **Disconnecting a User:** Call the Web API endpoint `POST /deauthenticateUser` (or `DELETE /user`) from your backend, providing the `user_id`.
*   **Historical Data Retrieval (Client-Side, direct to app):**
    ```swift
    let startDate = Calendar.current.date(byAdding: .day, value: -7, to: Date())!
    let endDate = Date()

    terra?.getDaily(type: .APPLE_HEALTH, startDate: startDate, endDate: endDate, toWebhook: false) { success, dataPayload, error in
        if success, let payload = dataPayload {
            // Process TerraDataPayload directly in the app
            // payload.type, payload.data (array of data objects), payload.user
        } else {
            print("Failed to get daily data: \(error?.localizedDescription ?? "Unknown error")")
        }
    }
    ```
*   **Writing Data to Apple Health (Client-Side):**
    *   `terra.postActivity(type: .APPLE_HEALTH, payload: terraActivityData) { success, error in ... }`
        *   `terraActivityData` needs `device_data` (e.g., `TerraDeviceData(name: "My App")`).
        *   Uses `HKWorkout` internally (deprecated iOS 17, but likely still functional or Terra updates).
    *   `terra.postNutrition(type: .APPLE_HEALTH, payload: terraNutritionData) { ... }`
    *   `terra.postBody(type: .APPLE_HEALTH, payload: terraBodyData) { ... }`
    *   **Planned Workouts (iOS 17+):**
        ```swift
        // Create TerraPlannedWorkout payload (see Web API section for structure)
        let plannedWorkout = TerraPlannedWorkout(...)
        if #available(iOS 17, *) {
            terra?.postPlannedWorkout(type: .APPLE_HEALTH, payload: plannedWorkout) { success, error in
                // ... handle result ...
            }
        } else {
            print("Planned Workouts require iOS 17+ for Apple Health SDK writing.")
        }
        ```

**3.5. Android SDK (Kotlin) - `terra-android` - Health Data Access (Pages 98-106 in PDF)**

*   **Security:** API Key on backend.
*   **Requirements:** Health Connect app installed on user's device. Android 28 (Pie) and above.
*   **Installation:** In `build.gradle (Module :app)`:
    ```gradle
    dependencies {
        implementation 'co.tryterra:terra-android:{LATEST_VERSION_FROM_MAVEN_CENTRAL}'
    }
    ```
    Add `mavenCentral()` to project-level `build.gradle` if not present. Sync project.
*   **Project Setup (Health Connect):**
    *   **User Onboarding:** Guide users to install Health Connect and grant permissions within the Health Connect app for *your app* and for *source apps* (e.g., Samsung Health, Google Fit) to write data *to* Health Connect.
    *   **`AndroidManifest.xml`:**
        *   **Permissions:** Declare `<uses-permission>` for *every* Health Connect data type your app intends to read.
            ```xml
            <uses-permission android:name="android.permission.health.READ_HEART_RATE"/>
            <uses-permission android:name="android.permission.health.READ_STEPS"/>
            <!-- Add all other relevant read permissions -->
            ```
            If you are *not* using a specific permission, you can add `tools:remove="android.permission.health.PERMISSION_NAME"` to the `<uses-permission>` tag to explicitly exclude it if it's inherited.
        *   **Privacy Policy Intent Filter:** Add to your activity that handles permission rationale:
            ```xml
            <activity android:name=".YourActivity">
                <intent-filter>
                    <action android:name="androidx.health.ACTION_SHOW_PERMISSIONS_RATIONALE" />
                </intent-filter>
                <intent-filter> <!-- For viewing permissions usage -->
                    <action android:name="android.intent.action.VIEW_PERMISSION_USAGE"/>
                    <category android:name="android.intent.category.HEALTH_PERMISSIONS"/>
                </intent-filter>
            </activity>
            ```
    *   **Google Health Connect API Access:** For production apps, you **must** apply for permissions to access the Health Connect API with Google using their application form.
*   **Initialization (SDK Library):**
    ```kotlin
    import co.tryterra.terra.Terra // Main SDK class
    // import co.tryterra.terra.TerraManager // May be needed for older examples/types

    private lateinit var terra: Terra // Store as a Activity/Fragment property

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // ... your other onCreate code ...

        Terra.instance("YOUR_DEV_ID", "YOUR_INTERNAL_USER_ID_OR_NULL", this) { manager, error ->
            if (manager != null) {
                this.terra = manager
                // SDK is ready, proceed to initConnection when needed
            } else {
                // Handle initialization error (e.g., log it)
                Log.e("TerraSDK", "Failed to initialize Terra: ${error?.message}")
            }
        }
    }
    ```
    *   Initialize once. Docs say "should be initialized every time your app is started".
*   **Initialize Connection (to Health Connect source, e.g., Samsung Health, Google Fit):**
    1.  **Backend:** Call `POST /v2/auth/generateAuthToken` to get `sdk_token`.
    2.  **Client (Kotlin):**
        ```kotlin
        // sdkTokenFromBackend = "..."
        val customPermissionsSet: Set<co.tryterra.terra.CustomPermissions> = emptySet() // or specify permissions
        val enableScheduler = true // For background updates to webhook

        terra.initConnection(
            connection = co.tryterra.terra.Connections.SAMSUNG, // Or .GOOGLE_FIT
            token = sdkTokenFromBackend,
            context = this, // Your Activity or Application context
            customPermissions = customPermissionsSet,
            schedulerOn = enableScheduler,
            startIntent = null // Deprecated, always pass null
        ) { success, error ->
            if (success) {
                Log.i("TerraSDK", "Health Connect (${co.tryterra.terra.Connections.SAMSUNG}) connection successful!")
            } else {
                Log.e("TerraSDK", "Health Connect connection failed: ${error?.message}")
            }
        }
        ```
        *   Health Connect permission prompt is shown by the system. Only appears once per set of permissions.
*   **Validate Connection:**
    ```kotlin
    val currentUserId = terra.getUserId() // Synchronous
    if (currentUserId != null) {
        Log.i("TerraSDK", "Active Health Connect user ID: $currentUserId")
    } else {
        Log.w("TerraSDK", "No active Health Connect connection.")
    }
    ```
*   **Disconnecting a User:** Call Web API `POST /deauthenticateUser` from backend.
*   **Historical Data Retrieval (Client-Side, direct to app):**
    ```kotlin
    val cal = Calendar.getInstance()
    cal.add(Calendar.DAY_OF_YEAR, -7)
    val startDate = cal.time
    val endDate = Date() // Now

    terra.getDaily(
        type = co.tryterra.terra.Connections.SAMSUNG,
        startDate = startDate,
        endDate = endDate,
        toWebhook = false // Data returned in callback
    ) { success, dataPayload, error ->
        if (success && dataPayload != null) {
            // Process dataPayload (co.tryterra.terra.TerraDataPayload)
            Log.i("TerraSDK", "Daily data received: ${dataPayload.data.size} records")
        } else {
            Log.e("TerraSDK", "Failed to get daily data: ${error?.message}")
        }
    }
    ```

**3.6. React Native SDK - `terra-react` - Health Data Access (Pages 107-119 in PDF)**

*   **Security:** API Key on backend.
*   **Installation:** `npm install terra-react` or `yarn add terra-react`.
*   **Native Project Setup:** **Crucial:** You must complete the native iOS (`TerraiOS`) and Android (`terra-android` with Health Connect) setup steps described in sections 3.4 and 3.5 within your React Native project's `/ios` and `/android` folders respectively. This includes:
    *   **iOS:** Adding TerraiOS Swift Package, configuring Capabilities (HealthKit, Background Modes), `Info.plist` entries (`NSHealthShareUsageDescription`, etc.), and modifying `AppDelegate.h`/`AppDelegate.m` (or `.swift`) to call `[Terra setUpBackgroundDelivery];` (Objective-C) or `Terra.setUpBackgroundDelivery()` (Swift).
    *   **Android:** Adding `terra-android` Gradle dependency, Health Connect setup in `AndroidManifest.xml` (permissions, intent filters), and ensuring your app is prepared for Google Health Connect API access review.
*   **Initialization (SDK Library):**
    ```javascript
    import { initTerra } from 'terra-react';
    import { useEffect } from 'react';

    const App = () => {
      useEffect(() => {
        const initializeTerra = async () => {
          try {
            const successMessage = await initTerra('YOUR_DEV_ID', 'YOUR_INTERNAL_USER_ID_OR_NULL');
            console.log('Terra React Native initialized successfully:', successMessage);
          } catch (error) {
            console.error('Failed to initialize Terra React Native:', error);
          }
        };
        initializeTerra();
      }, []);
      // ... rest of your app
    };
    ```
*   **Initialize Connection (to Apple Health / Health Connect source):**
    1.  **Backend:** Call `POST /v2/auth/generateAuthToken` to get `sdk_token`.
    2.  **Client (React Native):**
        ```javascript
        import { initConnection, Connections, CustomPermissions } from 'terra-react';

        const connectHealthSource = async (sdkTokenFromBackend) => {
          try {
            // For Apple Health:
            // const connectionType = Connections.APPLE;
            // For Health Connect (e.g., Samsung Health):
            const connectionType = Connections.SAMSUNG; // Or Connections.GOOGLE_FIT

            const customPermissionsArray = []; // E.g., [CustomPermissions.STEPS, CustomPermissions.HEART_RATE]
            const enableScheduler = true;

            const successMessage = await initConnection(
              connectionType,
              sdkTokenFromBackend,
              enableScheduler,
              customPermissionsArray,
              null // startIntent - deprecated, always null
            );
            console.log(`${connectionType} connection successful:`, successMessage);
          } catch (error) {
            console.error(`${connectionType} connection failed:`, error);
          }
        };
        ```
*   **Validate Connection:**
    ```javascript
    import { getUserId, Connections } from 'terra-react';

    const checkConnectionStatus = async () => {
      try {
        const userIdPayload = await getUserId(Connections.APPLE); // Or other connection type
        if (userIdPayload && userIdPayload.user_id) {
          console.log('Active User ID:', userIdPayload.user_id);
        } else {
          console.log('No active connection or user ID found.');
        }
      } catch (error) {
        console.error('Error getting user ID:', error);
      }
    };
    ```
*   **Disconnecting a User:** Call Web API `POST /deauthenticateUser` from backend.
*   **Historical Data Retrieval (Client-Side, direct to app):**
    ```javascript
    import { getDaily, Connections } from 'terra-react';

    const fetchHistoricalData = async () => {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 7); // 7 days ago
      const endDate = new Date();

      try {
        const dailyDataMessage = await getDaily(
          Connections.APPLE, // Or other connection type
          startDate,
          endDate,
          false // toWebhook: false to get data in response
        );
        if (dailyDataMessage.success && dailyDataMessage.data) {
          console.log('Daily data:', dailyDataMessage.data);
        } else {
          console.error('Failed to get daily data:', dailyDataMessage.error);
        }
      } catch (error) {
        console.error('Error fetching daily data:', error);
      }
    };
    ```
*   **Writing Data to Apple Health (iOS Only):**
    ```javascript
    import { postActivity, Connections, ActivityType } from 'terra-react';

    const writeActivityToAppleHealth = async () => {
      const activityPayload = {
        metadata: {
          name: 'Morning Run RN',
          start_time: new Date(Date.now() - 3600 * 1000).toISOString(), // 1 hour ago
          end_time: new Date().toISOString(),
          type: ActivityType.RUNNING,
        },
        device_data: { name: 'My React Native App' },
        heart_rate_data: { summary: { avg_hr_bpm: 130, max_hr_bpm: 160 } },
        distance_data: { summary: { distance_meters: 5000 } },
        calories_data: { total_burned_calories: 400 },
      };

      try {
        const response = await postActivity(Connections.APPLE, activityPayload);
        if (response.success) {
          console.log('Activity data posted successfully to Apple Health!');
        } else {
          console.error('Failed to post activity data:', response.error);
        }
      } catch (error) {
        console.error('Error posting activity data:', error);
      }
    };
    ```
    *   `postNutrition` and `postBody` are also available for `Connections.APPLE`.
    *   Planned Workouts via SDK not explicitly mentioned for RN in OCR, but if `TerraiOS` supports it, it might be bridgeable.

**3.7. Flutter SDK - `terra_flutter_bridge` - Health Data Access (Pages 120-133 in PDF)**

*   **Security:** API Key on backend.
*   **Installation:** In `pubspec.yaml`:
    ```yaml
    dependencies:
      terra_flutter_bridge: ^{LATEST_VERSION_FROM_PUB_DEV}
    ```
    Run `flutter pub get`.
*   **Native Project Setup:** **Crucial:** Complete native iOS (`TerraiOS`) and Android (`terra-android` with Health Connect) setup (sections 3.4, 3.5) in `/ios` and `/android` folders.
    *   **iOS:** Add TerraiOS Swift Package, Capabilities, `Info.plist`, `AppDelegate` modifications for `setUpBackgroundDelivery`.
    *   **Android:** Add `terra-android` Gradle dependency, Health Connect setup in `AndroidManifest.xml`, Google API access.
*   **Initialization (SDK Library):**
    ```dart
    import 'package:terra_flutter_bridge/terra_flutter_bridge.dart';
    import 'package:flutter/material.dart'; // For WidgetsFlutterBinding

    Future<void> initializeTerraFlutter() async {
      WidgetsFlutterBinding.ensureInitialized(); // Required before calling Terra init
      try {
        final String devID = 'YOUR_DEV_ID';
        final String? referenceID = 'YOUR_INTERNAL_USER_ID_OR_NULL';
        SuccessMessage? result = await TerraFlutterBridge.initTerra(devID, referenceID);

        if (result?.success == true) {
          print('Terra Flutter initialized successfully');
        } else {
          print('Terra Flutter initialization failed: ${result?.error}');
        }
      } catch (e) {
        print('Error during Terra Flutter initialization: $e');
      }
    }
    ```
*   **Initialize Connection (to Apple Health / Health Connect source):**
    1.  **Backend:** Call `POST /v2/auth/generateAuthToken` to get `sdk_token`.
    2.  **Client (Flutter):**
        ```dart
        // sdkTokenFromBackend = "..."
        // For Apple Health:
        // final connectionType = Connection.apple;
        // For Health Connect (e.g., Samsung Health):
        final connectionType = Connection.samsung; // Or Connection.googleFit

        final List<CustomPermission> customPermissionsList = []; // E.g., [CustomPermission.STEPS, CustomPermission.HEART_RATE]
        final bool enableScheduler = true;

        try {
          SuccessMessage? result = await TerraFlutterBridge.initConnection(
            connectionType,
            sdkTokenFromBackend,
            enableScheduler,
            customPermissionsList,
            // startIntent parameter is not present in the Flutter SDK OCR
          );
          if (result?.success == true) {
            print('${connectionType.toString()} connection successful!');
          } else {
            print('${connectionType.toString()} connection failed: ${result?.error}');
          }
        } catch (e) {
          print('Error connecting to ${connectionType.toString()}: $e');
        }
        ```
*   **Validate Connection:**
    ```dart
    Future<void> checkFlutterConnectionStatus() async {
      try {
        UserId? userIdResult = await TerraFlutterBridge.getUserId(Connection.apple); // Or other connection
        if (userIdResult?.userId != null) {
          print('Active User ID (Flutter): ${userIdResult!.userId}');
        } else {
          print('No active connection or user ID found (Flutter).');
        }
      } catch (e) {
        print('Error getting user ID (Flutter): $e');
      }
    }
    ```
*   **Disconnecting a User:** Call Web API `POST /deauthenticateUser` from backend.
*   **Historical Data Retrieval (Client-Side, direct to app):**
    ```dart
    Future<void> fetchFlutterHistoricalData() async {
      final DateTime endDate = DateTime.now();
      final DateTime startDate = endDate.subtract(Duration(days: 7));

      try {
        DataMessage? dailyDataMessage = await TerraFlutterBridge.getDaily(
          Connection.apple, // Or other connection
          startDate,
          endDate,
          false // toWebhook: false
        );
        if (dailyDataMessage?.success == true && dailyDataMessage?.data != null) {
          print('Daily data (Flutter): ${dailyDataMessage!.data}'); // data is List<dynamic>
        } else {
          print('Failed to get daily data (Flutter): ${dailyDataMessage?.error}');
        }
      } catch (e) {
        print('Error fetching daily data (Flutter): $e');
      }
    }
    ```
*   **Writing Planned Workouts to Apple Health (iOS 17+, Apple Only):**
    ```dart
    // Construct TerraPlannedWorkoutData payload (similar structure to Web API)
    // final TerraPlannedWorkoutData plannedWorkoutPayload = TerraPlannedWorkoutData(...);

    // if (Platform.isIOS) { // Ensure it's iOS
    //   // Check iOS version if possible for 17+
    //   try {
    //     SuccessMessage? response = await TerraFlutterBridge.postPlannedWorkout(
    //       Connection.apple, // Must be Apple
    //       plannedWorkoutPayload
    //     );
    //     if (response?.success == true) {
    //       print('Planned workout posted successfully to Apple Health (Flutter)!');
    //     } else {
    //       print('Failed to post planned workout (Flutter): ${response?.error}');
    //     }
    //   } catch (e) {
    //     print('Error posting planned workout (Flutter): $e');
    //   }
    // }
    ```
    (Note: The `TerraPlannedWorkoutData` class structure for Flutter would need to be inferred or found in the plugin's specific documentation, as it's not fully detailed in the OCR beyond the example usage.)

---

## 4. Streaming API (Real-Time) - Detailed

**Purpose:** Low-latency data streaming (e.g., per-second heart rate, steps) from wearables (via BLE/ANT+) or phone sensors, through a mobile app, to your backend.

**4.1. Overview & Components**

*   **Metrics:** Steps, Heart Rate, Distance covered, etc., on a ~per-second basis.
*   **Contrast:** Health & Fitness API is for longer-span/historical data (workouts, sleep, daily totals).
*   **Requirements:** Device broadcasts via BLE (Bluetooth Low Energy), ANT+, or specific custom Bluetooth protocols (e.g., Apple Watch, Polar H10). Can also use phone sensors.
*   **Architecture (Data Flow):**
    1.  **Wearable Device:** The source of raw sensor data (e.g., a heart rate strap, smartwatch).
    2.  **Producer (Mobile App):** Your mobile application running a Terra Real-Time (RT) SDK (`TerraRTiOS` or `terra-rtandroid`). It connects to the wearable, collects data, and forwards it.
    3.  **Terra WebSocket Broker:** Terra's central server (`ws.tryterra.co` - confirm endpoint). It receives data from producers and dispatches it to consumers.
    4.  **Consumer (Your Backend):** Your server-side application that connects to the Terra WebSocket Broker to receive the real-time data stream.

**4.2. Workflow Part 1: Wearable -> App (Producer RT SDK Setup)**

*   **RT SDKs:**
    *   iOS (Swift): `TerraRTiOS` (from `https://github.com/tryterra/TerraRTiOS`).
    *   Android (Kotlin): `terra-rtandroid` (from Maven Central, e.g., `co.tryterra:terra-rtandroid:X.X.X`).
    *   React Native / Flutter: Would require bridging to these native RT SDKs. The OCR does not explicitly detail RT SDK wrappers for RN/Flutter beyond the standard SDKs. Assume native implementation or custom bridging for now if RT is needed in RN/Flutter.
*   **A. iOS Setup (`TerraRTiOS`):**
    *   **Installation:** Add `TerraRTiOS` Swift Package.
    *   **`Info.plist`:**
        *   `Privacy - Bluetooth Always Usage Description` (NSBluetoothAlwaysUsageDescription): For BLE scanning and connection.
        *   `Privacy - Motion Usage Description` (NSMotionUsageDescription): If intending to stream phone's motion sensor data.
    *   **Apple Developer Program:** Real-time streaming on iOS is only available to those registered on the Apple Developer Program.
*   **B. Android Setup (`terra-rtandroid`):**
    *   **Installation:** Add Gradle dependency: `implementation 'co.tryterra:terra-rtandroid:{LATEST_VERSION}'`.
    *   **Permissions (`AndroidManifest.xml`):**
        *   `<uses-permission android:name="android.permission.BLUETOOTH_SCAN"/>` (for API 31+)
        *   `<uses-permission android:name="android.permission.BLUETOOTH_CONNECT"/>` (for API 31+)
        *   `<uses-permission android:name="android.permission.BLUETOOTH"/>` (for older APIs)
        *   `<uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>` (for older APIs)
        *   `<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>` (Required for BLE scanning on many Android versions).
        *   Possibly others depending on specific ANT+ or sensor usage.
*   **C. Initialization (Both Platforms - RT SDK Library):**
    *   Import the RT SDK.
    *   Create and store an instance of the `TerraRT` class.
        *   **iOS:** `let terraRT = TerraRT(devId: "YOUR_DEV_ID", referenceId: "YOUR_INTERNAL_USER_ID_OR_NIL") { success in /* ... */ }`
        *   **Android:** `terraRT = TerraRT(devId = "YOUR_DEV_ID", context = this, referenceId = "YOUR_INTERNAL_USER_ID_OR_NIL") { success -> /* ... */ }`
    *   Initialize this when the app is launched or brought to the foreground.
*   **D. Step 1: Connect the Phone Itself as a Streaming Producer:**
    *   **Backend Call:** Your server calls `POST /v2/auth/generateAuthToken` to get a single-use token. (This is the *same endpoint* used for standard Mobile SDK initialization, but the token's purpose here is to authenticate the phone app as a *producer* to the streaming service).
    *   **Mobile RT SDK Call:**
        *   **iOS:** `terraRT.initConnection(token: "token_from_backend_for_phone_producer") { success in /* ... */ }`
        *   **Android:** `terraRT.initConnection(token = "token_from_backend_for_phone_producer") { success -> /* ... */ }`
    *   This registers the phone with Terra's streaming infrastructure.
*   **E. Step 2: Scan and Connect to a Wearable Device:**
    *   **Mobile RT SDK Call:**
        *   **iOS:** `terraRT.startBluetoothScan(type: .BLE) { success in /* ... */ }` (Shows a modal UI for device selection).
        *   **Android:** `terraRT.startDeviceScan(type = Connections.BLE) { success -> /* ... */ }` (Can use cached devices or show widget).
    *   This establishes a Bluetooth connection between the phone app and the wearable.
*   **F. Step 3: Start Streaming Data (From Wearable *to the App Itself*):**
    *   **Mobile RT SDK Call:**
        *   **iOS:** `terraRT.startRealtime(type: .BLE, dataType: [.heartRate, .steps]) { update: TerraRTiOS.Update in handleInAppUpdate(update) }`
        *   **Android:** `terraRT.startRealtime(type = Connections.BLE, dataTypes = setOf(DataTypes.HEART_RATE, DataTypes.STEPS)) { update: Update -> handleInAppUpdate(update) }`
    *   The `handleInAppUpdate` callback receives data packets (timestamp, type, value) from the connected wearable *within the mobile app*. This is useful for displaying live data in the app's UI.
*   **G. Step 4: Stop In-App Streaming / Disconnect Device:**
    *   `terraRT.stopRealtime(type: .BLE)` (or relevant connection type)
    *   `terraRT.disconnect(type: .BLE)` (or relevant connection type)

**4.3. Workflow Part 2: App -> Broker (Forwarding Data to Terra)**

*   **Purpose:** To send the real-time data (that the app is receiving from the wearable as per section 4.2.F) to the Terra WebSocket Broker.
*   **Step 1: Generate User Streaming Token (Backend Call):**
    *   Your server calls: `POST /auth/user`
        *   **Headers:** `dev-id: YOUR_DEV_ID`, `x-api-key: YOUR_API_KEY`.
        *   **Query Parameter:** `id` (string, **required**): The Terra `user_id` of the end-user whose data is being streamed. This `user_id` must have been previously obtained through the Health & Fitness API authentication flow (Section 2.3) or a Mobile SDK connection (Section 3).
        *   **Response (200 OK):** `{"token": "USER_STREAMING_TOKEN_FOR_THIS_USER_SESSION"}`
    *   Your backend sends this `USER_STREAMING_TOKEN_FOR_THIS_USER_SESSION` to the mobile app.
*   **Step 2: Start Streaming to Broker (Mobile App - Modified `startRealtime` call):**
    *   The RT SDKs provide a variant of `startRealtime` that accepts this user-specific streaming token and a `connectionCallback` to indicate if the connection *to the broker* was successful.
    *   **iOS (`TerraRTiOS`):**
        ```swift
        let userStreamingToken = "TOKEN_FROM_BACKEND_AUTH_USER"
        terraRT.startRealtime(
            type: .BLE,
            dataType: dataTypes,
            token: userStreamingToken, // This is the key addition
            realtimeCallback: { update in // For in-app data
                handleInAppUpdate(update: update)
            },
            connectionCallback: { success in // For broker connection status
                if success { print("Successfully connected to Terra Broker for user data streaming.") }
                else { print("Failed to connect to Terra Broker for streaming.") }
            }
        )
        ```
    *   **Android (`terra-rtandroid`):**
        ```kotlin
        val userStreamingToken = "TOKEN_FROM_BACKEND_AUTH_USER"
        terraRT.startRealtime(
            type = Connections.BLE,
            dataTypes = dataTypes,
            token = userStreamingToken, // Key addition
            updateHandler = { update -> handleInAppUpdate(update) }, // For in-app data
            connectionCallback = { success -> // For broker connection status
                if (success) { println("Successfully connected to Terra Broker for user data streaming.") }
                else { println("Failed to connect to Terra Broker for streaming.") }
            }
        )
        ```
    *   Once `connectionCallback` reports `success`, the mobile app is actively forwarding the data for that `user_id` (associated with the `userStreamingToken`) to the Terra WebSocket Broker.

**4.4. Workflow Part 3: Broker -> Your Backend (Consumer Setup)**

*   **Purpose:** Your backend service connects to the Terra WebSocket Broker to receive the real-time data streams forwarded by mobile producer apps.
*   **Protocol:** WebSocket. The endpoint is likely `wss://ws.tryterra.co` (verify with Terra).
*   **Lifecycle & Payloads (Op Codes - Operations):**
    1.  **Connect:** Your backend establishes a WebSocket connection to the Terra Broker.
    2.  **Receive HELLO (Op 2):** Immediately upon connection, the Broker sends:
        ```json
        { "op": 2, "d": { "heartbeat_interval": 40000 } }
        ```
        *   `heartbeat_interval` is in milliseconds. Your client must respect this for heartbeating.
    3.  **Send Heartbeat (Op 0) & Receive Heartbeat ACK (Op 1):**
        *   To keep the WebSocket connection alive, your client **must** send heartbeats.
        *   **Client Sends:** `{ "op": 0 }`
        *   **Broker Responds:** `{ "op": 1 }` (acknowledging the heartbeat)
        *   **Timing:**
            *   The *first* heartbeat should be sent after `heartbeat_interval * jitter` milliseconds, where `jitter` is a random value between 0.1 and 1.0.
            *   Subsequent heartbeats should be sent *at most* at the `heartbeat_interval` specified in the HELLO payload.
            *   If a Heartbeat ACK (Op 1) is not received after sending a heartbeat, the client should assume the connection is dead, close it, and attempt to re-establish.
    4.  **Send IDENTIFY (Op 3):** After receiving Op 2 HELLO and successfully initiating heartbeating, your client must authenticate itself as a consumer.
        *   **Client Sends:**
            ```json
            {
              "op": 3,
              "d": {
                "token": "YOUR_TERRA_API_KEY", // Use your main x-api-key here
                "type": 0 // Type 0 indicates a consumer connection
              }
            }
            ```
    5.  **Receive READY (Op 4):** If the IDENTIFY payload is valid, the Broker responds with:
        ```json
        { "op": 4 }
        ```
        *   The connection is now authenticated and ready to receive data dispatches.
    6.  **Receive DISPATCH (Op 5):** The Broker sends data payloads as they arrive from producer apps:
        ```json
        {
          "op": 5,
          "d": { // The actual data payload from the sensor/wearable
            "t": "2022-05-04T10:26:11.268507+01:00", // Timestamp of the data point
            "val": 95 // Value of the data point (e.g., heart rate BPM)
            // 'd' structure can vary for more complex data like accelerometer
          },
          "uid": "TERRA_USER_ID_OF_DATA_SOURCE", // The Terra user_id this data belongs to
          "seq": 73, // Sequence number for this user's stream. Increments for each message.
          "t": "HEART_RATE" // Type of data (e.g., "STEPS", "CALORIES", "DISTANCE", "ACCELEROMETER_X")
        }
        ```
        *   `uid`: Critical for associating the data with the correct end-user in your system.
        *   `seq`: Use this to detect missed messages if your connection drops and then re-establishes.
        *   `t` (top-level): The data type string.
        *   `d` (nested): Contains the data point itself, usually with its own timestamp (`t`) and value (`val`).
    7.  **Send REPLAY (Op 7) (Optional - For Recovering Missed Data):** If your consumer disconnects and later reconnects, you can use the `seq` numbers to request missed data.
        *   **Client Sends:**
            ```json
            {
              "op": 7,
              "d": {
                "after": 72,  // The sequence number of the last message you successfully processed
                "before": 75 // (Optional) The sequence number up to which you want to replay
              }
            }
            ```
        *   The Broker will attempt to re-send messages with `seq` numbers greater than `after` (and less than or equal to `before`, if specified).

**4.5. WatchOS Streaming Integration (Apple Watch as Source)**

*   **Concept:** The Apple Watch, via a companion WatchOS app using `TerraRTiOS`, can act as a direct data source for streaming. The paired iOS app (also using `TerraRTiOS`) listens to this stream and can then forward it to the Terra Broker (as per section 4.3).
*   **Setup (Recap from PDF pages 145-150):**
    *   **Xcode Project:** Create a WatchOS target within your iOS project.
    *   **WatchOS App:**
        *   Add `TerraRTiOS` Swift Package to the WatchOS target.
        *   **Capabilities:** Enable HealthKit and Background Modes for the WatchOS app target.
        *   **`Info.plist` (WatchOS):** Add necessary privacy keys:
            *   `Privacy - Health Share Usage Description` (NSHealthShareUsageDescription)
            *   `Privacy - Health Update Usage Description` (NSHealthUpdateUsageDescription)
            *   `Privacy - Health Records Usage Description` (NSHealthClinicalHealthRecordsShareUsageDescription) - if applicable.
*   **WatchOS App Code (`InterfaceController` using `TerraRTiOS`):**
    ```swift
    import WatchKit
    import TerraRTiOS // For the Watch

    class InterfaceController: WKInterfaceController {
        var terraRT_watch: TerraRTiOS.Terra? // Note: PDF shows 'Terra?', class name might be 'TerraRTiOS.Terra' or similar

        override func awake(withContext context: Any?) {
            super.awake(withContext: context)
            do {
                terraRT_watch = try TerraRTiOS.Terra() // Initialize on watch
                terraRT_watch?.connect() // Connects this watch SDK instance (manages internal state)
                print("WatchOS Terra SDK Initialized and Connected")
            } catch {
                print("WatchOS Terra SDK init/connect failed: \(error)")
            }
        }

        @IBAction func startStreamingDataOnWatch() {
            let dataTypes: Set<TerraRTiOS.ReadTypes> = [.HEART_RATE, .STEPS] // Use ReadTypes enum
            terraRT_watch?.startStream(forDataTypes: dataTypes) { success, error in
                if success { print("Watch streaming TO PAIRED IOS APP started") }
                else { print("Watch streaming failed to start: \(error?.localizedDescription ?? "unknown error")") }
            }
        }

        @IBAction func stopStreamingDataOnWatch() {
            terraRT_watch?.stopStream()
            print("Watch streaming stopped")
        }

        // For workouts (enhances data frequency)
        @IBAction func startWatchExercise() {
            // Example for .RUNNING type, use appropriate HKWorkoutActivityType
            terraRT_watch?.startExercise(forType: .RUNNING) { success, error in /* ... */ }
        }
        @IBAction func stopWatchExercise() { terraRT_watch?.stopExercise { /* ... */ } }
        @IBAction func pauseWatchExercise() { terraRT_watch?.pauseExercise() }
        @IBAction func resumeWatchExercise() { terraRT_watch?.resumeExercise() }
    }
    ```
*   **iOS App Code (Listening to Watch Stream, using `TerraRTiOS`):**
    ```swift
    // In your iOS ViewController or class managing the main TerraRT instance (terraRT from 4.2.C)

    func setupWatchOSListener() {
        terraRT?.connectWithWatchOS() { success in // Establishes a channel with the companion Watch app
            if success {
                print("Connection to WatchOS companion app successful.")
                // Now, listen for data streamed FROM the watch TO this iOS app
                let watchDataTypes: Set<TerraRTiOS.DataTypes> = [.HEART_RATE, .STEPS] // Use DataTypes enum
                terraRT?.startRealtime(type: .WATCH_OS, dataTypes: watchDataTypes) { update: TerraRTiOS.Update in
                    print("iOS App: Received update from WatchOS: \(update.type) val: \(update.val ?? 0.0)")
                    // This 'update' can now be forwarded to the Terra Broker using the
                    // userStreamingToken method if desired (see section 4.3).
                }
            } else {
                print("Failed to connect with WatchOS companion app.")
            }
        }
    }

    // Functions to control workout on Watch from iOS
    func pauseWorkoutOnWatch() { terraRT?.pauseWatchOSWorkout() }
    func resumeWorkoutOnWatch() { terraRT?.resumeWatchOSWorkout() }
    func stopWorkoutOnWatch() { terraRT?.stopWatchOSWorkout { /* ... */ } }
    ```
    *   **Note:** The data received by the iOS app from `.WATCH_OS` type stream is then handled like any other in-app real-time data. If it needs to go to your backend, the iOS app uses its `userStreamingToken` (from `/auth/user`) and forwards it to the Terra Broker using the `startRealtime` variant with the `token` and `connectionCallback` for broker connection, specifying `.WATCH_OS` as the source type if that's how Terra internally distinguishes it for the broker, or it might just be generic data from the phone producer. The OCR is less explicit on how `.WATCH_OS` data is tagged when *sent to the broker*. Typically, the broker cares about the `user_id` linked to the `userStreamingToken`.

---

## 5. Teams API [BETA]

*   **Purpose:** Connect to specialized sports science equipment such as dynamometers, player position tracking units, and similar devices.
*   **Functionality (as per docs):**
    *   View data aggregated across multiple players for team games or events.
    *   Access data from individual force production tests.
    *   And more (implying other specialized data types).
*   **Status:** Beta. (Limited details beyond this high-level description in the provided PDF documentation).
*   **Implementation:** Likely involves specific API endpoints for team/player management, device registration for these specialized units, and data retrieval endpoints tailored to the unique data these devices produce. Authentication would still use `dev-id` and `x-api-key`.

---

## 6. Biomarkers API [Upcoming]

*   **Purpose:** Expected to provide access to biomarker data. This could include results from lab tests (e.g., blood panels, hormone levels) or other biological markers.
*   **Status:** Upcoming. (No further details available in the provided PDF documentation).

---

## 7. Combined Debugging FAQ & Troubleshooting

This section consolidates common issues and debugging steps across all Terra components.

*   **Authentication & Connection Issues:**
    *   **Incorrect API Key/Dev ID:** Ensure you are using the correct `dev-id` and `x-api-key` from your Terra Dashboard. For server-side calls.
    *   **Expired/Invalid SDK/Streaming Tokens:** Tokens generated by `/v2/auth/generateAuthToken` (for SDK init) and `/auth/user` (for streaming to broker) are single-use and/or short-lived. Ensure your backend generates a fresh one when needed.
    *   **User Logged into Wrong Provider Account:** This is a common source of "missing data."
        *   **Verification:** Use the Terra API (`GET /athlete?user_id=...` or `/userInfo?user_id=...`) to retrieve the `provider_user_id` that Terra has stored for the connection.
        *   **Compare:** Ask the user to find their ID within their native provider app or website (e.g., Fitbit app profile, Garmin Connect profile online, MyFitnessPal diary URL, Freestyle Libre patient profile URL).
        *   **Examples from Docs:**
            *   Freestyle Libre: URL format `https://www.libreview.com/patient/{provider_user_id}/profile`.
            *   Fitbit: In Fitbit app: Avatar (top left) -> Tap display name -> Personal -> Fitbit User ID at bottom.
            *   MyFitnessPal: Diary URL `https://www.myfitnesspal.com/food/diary/{provider_user_id}`. If this URL shows "Invalid username", the user likely entered their email instead of MFP username during Terra auth. If it shows "Diary sharing is disabled", they need to enable it in MFP settings.
        *   **Resolution:** If mismatched, guide the user to deauthorize the incorrect account (via your app or Terra Dashboard if user has access) and re-authenticate with the correct provider account.
*   **Data Syncing Issues (Data appears in native provider app but not via Terra):**
    *   **Step 1: Check Provider's Cloud/Web Dashboard:** Data must sync from wearable -> native app -> provider's cloud servers before Terra can access it. Verify data is visible on the provider's official website (e.g., connect.garmin.com, fitbit.com dashboard).
    *   **Step 2: Force Sync in Native App:** Ask user to manually trigger a sync in the provider's app.
    *   **Step 3: Check for Known API Delays:**
        *   Garmin Connect: Can take 1-2 minutes *after* data appears on Garmin's web dashboard for it to be available via API.
        *   Google Fit (via Health Connect): Can have delays of 30-60 minutes.
    *   **Step 4: Specific Provider Settings:**
        *   MyFitnessPal: Ensure "Diary Sharing" is enabled in MFP settings for the connected account.
*   **Mobile SDK Specific Sync Issues:**
    *   **Apple Health (iOS):**
        *   **Background App Refresh:** Must be enabled system-wide (Settings > General > Background App Refresh) AND for your specific app.
        *   **Low Power Mode:** Must be OFF, as it restricts background activity.
        *   **Device Locked:** HealthKit often restricts background data delivery until the device is unlocked.
        *   **Debugging with Backfill:** Use the Terra Dashboard (Tools > Debug > Users > Request Data for `user_id`) to trigger a historical data pull for Apple Health. If data comes through this way, it indicates the initial connection is fine, but background delivery might be the issue. Requires `TerraiOS >= 1.6.12`.
    *   **Google Fit / Health Connect (Android):**
        *   **Health Connect App:** Must be installed, and user must grant permissions *within Health Connect* for your app to read data, and for source apps (like Samsung Health, Google Fit app) to *write* data *to* Health Connect.
        *   **`AndroidManifest.xml`:** Double-check all required permissions and intent filters are correctly configured.
        *   **Google API Access:** Ensure your application for Health Connect API access (for production) has been approved by Google.
        *   **Platform Immaturity:** Health Connect is a newer platform. Bugs or sync inconsistencies can occur between source apps and Health Connect itself.
*   **Webhook Destination Errors:**
    *   **Server-Side Errors (5xx):** If your webhook endpoint returns a 5xx HTTP status code, Terra will retry sending the event with exponential backoff for approximately 24 hours. Check your server logs to identify and fix the cause of the error.
    *   **Client-Side Errors (4xx):** If your endpoint returns a 4xx, Terra typically will *not* retry. Ensure your endpoint logic is correct.
    *   **Idempotency:** Design your webhook handler to be idempotent if possible (i.e., processing the same event multiple times has no additional adverse effect), as retries can lead to duplicate deliveries.
*   **Streaming API Troubleshooting:**
    *   **Token Mismatch:** Ensure correct tokens are used:
        *   Phone Producer Init: Token from `/v2/auth/generateAuthToken` used in RT SDK's `initConnection`.
        *   User Data Streaming to Broker: Token from `/auth/user` (with `user_id`) used in RT SDK's `startRealtime` (broker-connected variant).
        *   Backend Consumer Auth: Your main Terra API Key (`x-api-key`) used in WebSocket `IDENTIFY` (Op 3) payload.
    *   **WebSocket Connection Stability:** Monitor heartbeats (Op 0 from client, Op 1 from broker). If ACKs are missed, re-establish the WebSocket connection.
    *   **RT SDK Callbacks:** Check the `success` status in `connectionCallback` of the RT SDK's `startRealtime` (broker-connected variant) to ensure the app successfully connected to the Terra Broker.
    *   **Correct `user_id` for `/auth/user`:** The `id` parameter for `/auth/user` (generating user streaming token) *must* be the Terra `user_id` of the user whose data is being streamed.
*   **Testing & Development Limits:**
    *   **User Limits (Dashboard/API):** Be aware of user limits (e.g., 50 users) in testing environments. De-authenticate test users (`POST /deauthenticateUser` or via Dashboard) if you hit the limit.
*   **Terra Dashboard Tools:**
    *   **Payload Simulator:** Send test events (auth, data types) to your configured webhook Destination.
    *   **User Debugging (Users Tab):** View connection status for a `user_id`, request historical data, potentially trigger backfills.

---

## 8. Security Best Practices Summary

*   **API Key (`x-api-key`):** This is highly sensitive. **NEVER embed it directly in client-side code (mobile app, frontend JavaScript).** It should only be used for server-to-server API calls from your backend.
*   **Tokens (SDK & Streaming):**
    *   **SDK Initialization Token (`/v2/auth/generateAuthToken`):** Generated by your backend and passed to the mobile client. It's single-use or short-lived, mitigating risk if intercepted.
    *   **User Streaming Token (`/auth/user`):** Generated by your backend (requires `user_id`) and passed to the mobile client for RT SDK to connect to the broker.
    *   **Consumer Streaming Token (API Key):** Your main API Key is used by your backend to authenticate with the WebSocket broker (`IDENTIFY` Op 3).
*   **Authentication URLs / Widget Redirection:**
    *   **NO WebViews/IFrames for Auth:** Due to security risks (URL bar spoofing, clickjacking), providers may block authentication attempts from WebViews or iframes. **Always use a secure in-app browser** (like `SFSafariViewController` on iOS, Chrome Custom Tabs on Android) or redirect to the system's default browser for provider login.
*   **`reference_id`:** Use this consistently and correctly during user authentication to reliably map Terra's `user_id` back to your application's internal user identifier. This is crucial for data integrity and associating data with the correct user in your system.
*   **Webhook Security:**
    *   Use HTTPS for your Destination URL.
    *   If Terra provides webhook signature verification (e.g., using a shared secret and HMAC), implement it to ensure incoming requests are genuinely from Terra. (The OCR mentions `terra.check_signature(...)` for webhooks in an example, implying this capability exists).
*   **Data Handling & Storage:**
    *   Store sensitive health data securely, complying with relevant data privacy regulations (e.g., GDPR, HIPAA if applicable).
    *   Implement robust error handling and data validation on your backend when processing webhook data.
    *   Assume webhook data is a superset; use unique identifiers to overwrite or update your stored records correctly.

---

## 9. Version & Updates

*   **Document Basis:** This context is derived from the "Terra Docs" PDF (173 pages) provided.
*   **API/SDK Evolution:** APIs and SDKs are subject to change. Always refer to the **official live Terra documentation (docs.tryterra.co)** and the **changelogs/release notes** for specific SDKs (on GitHub, pub.dev, Maven Central) for the most current information, new features, breaking changes, and bug fixes.
*   **SDK Versions:** Ensure you are using up-to-date versions of Terra SDKs in your mobile applications by checking their respective package managers. The OCR often placeholders version numbers like `{VERSION_NUMBER}`.
*   **Provider Changes:** Be aware that individual data providers (Garmin, Fitbit, etc.) may change their own APIs or terms, which could impact Terra's integrations.
